[TOC]

1. [Go安装与环境配置](install_and_configure.md)
2. [如何编写Go代码](how_to_write_go_code.md)
3. Language Specification
4. Effective Go
5. [Package Documentation](std_package.md) <----
6. Command Documentaion
7. The Go Memory Model

- Editor plugins and IDEs
- Diagnostics
- Frequently Asked Questions

## 字面值

**整型字面值**

整型字面值用于表示整型常量。可在字面值中添加前缀用来改变数值的基数：0b,0B表示二进制字面值；0,0o,0O表示八进制，0x,0X表示十六进制。单独0表示十进制数值。在十六进制字面值中，a-f或A-F表示数值10-15。

```go
42       // decimal
0b101010 // binary
052      // octal
0x2A     // hex
```

为改善数值的可读性，可以在基数前缀后或者两个合法的数字之间使用下划线分隔。下划线不会改变字面值等大小。

```go
0b_0010_1010 // binary
0x_2A        // hex
```

**浮点数字面值**

浮点数字面值表示浮点数常量。总体上，浮点数由`[整数部分] + [小数点] + [小数部分] + [指数部分]`组成。浮点数可以使用十进制或十六进制表示。在十进制中指数部分由字母e,E开始表示，表示10的指数幂。十六进制则使用p,P表示，指数部分数字只能使用十进制数表示。十六进制中指数表示2的指数幂。和整数值一样，浮点数字面值也可以使用下划线来提高可读性。

注意：使用十六进制表示浮点数时，必须包含指数部分。

```go
1024.2
10.242E2

0.15
.15
15E-2

24.0
24.

0xA.0p2
0xA.p2

0x.Fp-2
```

**虚数字面值**

虚数字面值用于表示复数的虚数部分。由整数或浮点数加上小写字母i作为后缀组成。

为了向后兼容，虚数整数部分如果完全由十进制数字表示，则被看做十进制整数，即使是以0开头。

```
0123i // 虚数为整数，全部有十进制数字表示，则这个字面值表示十进制整数
0o123i // 八进制数，因为整数部分不是全部使用十进制数表示
0x5Ai // 十六进制数

123.45i
213.4E-2i
0x55.p2i
```

**符号（Rune）字面值**

符号字面值用于表示符号常量。符号常量是使用一个整型值标识的统一代码点(unicode code point)。一个符号常量可以表达在单引号中的一个或者多个字符。单引号中只有一个字符时，即表示其该字符本身的unicode值。以下划线开始的多个字符则有多种方式来编码值。

Go的源文件由UTF-8编码的unicode字符组成，多个UTF-8编码的字节可以表示一个整型值。例如：符号 'a'，表示字面值a，unicode编码为U+0061,整型值为0x61。符号'我'，使用了两个字节，表示汉字`我`，对应unicode U+6621，值为0x6621。

有四种使用转义方式来表示整型常量：

- `\xXX` 两个十六进制数，如：'\xAF'
- `\uXXXX` 四个十六进制数，'\u15AC'
- `\UXXXXXXXX` 八个十六进制数，'\U12AB34CD'
- `\OOO` 三个八进制数，`\777`

其他使用转移字符表示的含义如下：

- `\a` 警报或铃声
- `\b` 退格
- `\f` 换页符
- `\n` 换行符
- `\r` 回车
- `\t` 水平制表符
- `\v` 垂直制表符
- `\\` 反斜杠字面值
- `\'` 单引号字面值
- `\"` 双引号字面值

**字符串字面值**

字符串字面值有两种表示方式：

- 双引号包围的一系列符号
- \`\`表示的一些列符号

第二种方式成为原始字符串。即反引号\`\`中包围的符号都是字符串的字面值。



## 常量

## 变量

## 类型

### 基本类型

**布尔类型**

- `bool`

`true` | `false`

**数值类型**

- `uint8`
- `uint16`
- `uint32`
- `uint64`
- `int8`
- `int16`
- `int32`
- `int64`
- `float32`
- `float64`
- `complex64`
- `complex128`
- `byte` uint8的别名
- `rune` int32的别名

以下是与实现相关的类型：
- `uint` 32或64位
- `int` 32或64位
- `uintptr`

在表达式或复制运算中，如果是不同类型参与运算，需要进行显式转换。


### 复合类型

**字符串**

- `string`

字符串是不可修改的，一旦创建就不能改变其内容。

**数组**

- `[<size>]<element_type>`

数组是一维的，但可以通过存放数组类型的元素使其表示多维数组。如：

```
[2][3]int
```

**切片**

- `[]<element_type>`

切片类型是底层数组的一段连续元素序列的描述符。切片中元素可以通过索引引用。切片一旦初始化后就和其底层数组相关联。因此切片总是会和其他关联同一数组的切片共享该数组。

切片有两种创建方式：

- 使用`make`方法，直接创建。
- 对已存在数组进行切片引用。

**结构**

结构是一系列命名元素序列，称之为字段。每个字段都有名称和类型。字段名称可选。在结构中，非空白字段名称**必须唯一**。

声明了类型，但是没有名称的字段被称为嵌入字段。嵌入字段必须声明类型，或者指向该类型的指针类型。类型本身不能是指针，以及指针不能指向接口类型。没有定义名称的字段，其类型就是名称。

**？？字段提升？？**

字段声明可以跟一个可选的字符串tag。该tag成为对应字段的属性。空字符串tag等于没有tag。tag在反射接口中可见，且作为结构类型标识的一部分，在其他情况则会被忽略。

**Map** 

- `map[<key>]<val>`

map类型初始值为`nil`。通过内置函数`make`。map的长度即其所含元素的数量，通过内置函数`len`可获取。

### 指针

- `*<T>`

指针默认值是`nil`。

### 函数

函数类型表示了具有相同参数和返回值的所有函数。函数类型的默认值是`nil`。

在函数的参数列表或者返回值列表中，名称必须都出现或者都不出现。如果出现了，所有非空白名称都必须唯一。参数列表和返回值列表必须使用括号包围。除了返回值只有一项，且没有名称时。

函数的参数列表最后一个参数可能写成`...<type>`的形式，它表示可变参数，可以用于传入任意数量的参数。

### 接口

- `interface {}`

接口定义了一组被称为接口的方法。接口类型的变量可以存储任何方法集合中包含了该接口的方法的类型的变量。这种类型被称为实现了该接口。未初始化的接口变量初始值为`nil`。

接口可以显式定义自己的方法，也可以通过其他接口类型的名字来嵌入其他的接口。接口中定义的方法，名称必须唯一且不为空。

类型可以同时实现不同的接口。所有类型都实现了空接口类型`interface{}`。

接口不能循环嵌入自己。

### channel

- `chan <type>` 可同时发送和接收数据
- `chan<- <type>` 只能发送数据
- `<-chan <type>` 只能接收数据

channel类型为初始化时，默认值是`nil`。通过`make`初始化。创建channel时可传入channel的容量，表示该通道是有缓存的。即在缓存没有满的情况下，可以继续向通道传入数据。如果容量为0或没有设置，表示通道没有缓存。这种情况下必须在发送者和接受者都准备好后才能工作。

通过可以使用内置的`close`函数关闭。

## 类型和值的属性

### 类型标识

Go语言中，对于两种类型来说，要么完全相同，要么就不同。

定义的类型(defined type)总是和其他类型不同；否则两种类型如果底层类型在字面上完全一致则是相同的类型。

### 可赋值性

只要满足以下任意一个条件，一个值x就可以赋值给类型T的变量：

- x的类型和T一致
- x的类型V和类型T有相同的底层类型，且V,T中至少有一个不是定义的类型
- T是接口类型，且x实现了T
- x是一个双向通道类型值，T是一个通道类型，x的类型V和类型T有相同的元素类型，且V,T至少有一个不是定义的类型
- x是nil，T是指针，函数，切片，map，通道或者接口类型
- x是可使用T类型值表示的未定义类型

### 可表示性

如果以下任一条件满足，常量x就可以使用类型T的值表示：

- x是属于类型T定义的
- T是浮点类型，x可以四舍五入到T的精度且不会溢出
- T是复数类型，x的实部和虚部可使用T类型的实部虚部类型分别表示

## 块

## 声明与作用域

在一个包中，`init`标识符只能被用于`init`函数的声明。

### 空白标识符

空白标识符使用字符下划线`_`表示。

### 预定义标识符

即Go内置的标识符，如内置类型，函数，true,false,iota,nil等。

### 导出标识符

一个包可以导出包含的声明符，然后提供给其他包访问。如果：

- 声明符第一个字母是大写
- 声明符生命在包作用域，或者是字段名，方法名。

### 声明符的唯一性

### 常量声明

```go
const one,two int32 = 12,13
const (
	three,four int32 = 14,15
	five = 15
	six = 16
)
```

### iota

用于表示常量值，在`const`出现后，iota的值为0，此后一次递增，知道下一个const。

### 类型声明

类型声明将一个声明符（类型名）绑定到一个类型上。类型声明有两种形式：

- 别名声明
- 类型定义

#### 别名声明

- type \<identifier\> = \<type\>

别名声明将一个声明符绑定到给定类型上。

#### 类型定义

- type \<identifier\> \<type\>

类型定义可以使用相同的底层类型及其操作创建新的，不同的类型，并为该新的类型绑定一个标识符。

新创建的类型即被称为`定义的类型(defined type)`。它不和其他任何类型相同，包括其底层类型。

定义类型可以创建自己的方法。它不会继承来自底层类型的方法。但接口类型的方法集，以及组合类型的元素不会发生改变。

### 变量声明

变量声明创建一个或多个变量，并绑定声明符，给定类型和初始值。

```go
var zero
var one, two int = 1,2
var (
	three = 3
	four int32 = 4
	five,six = 5,6
)
```

`nil`不能初始化没有明确给定类型的变量。

### 短变量声明

- \<identifier list\> := \<value list\>

短变量声明可以重新初始化在同一作用域中已经声明的变量，但要求其重新声明时保持和原来相同类型，且声明列表中至少有一个变量是新建创建的。

### 函数声明

函数声明可以舍去函数体。这为在Go外部实现的函数提供一个函数签名。

### 方法声明

方法绑定到结构体类型时，方法不能和结构体中字段重名。

## 表达式


## 语句

